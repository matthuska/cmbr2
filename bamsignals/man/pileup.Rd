% Generated by roxygen2 (4.0.2): do not edit by hand
\name{pileup}
\alias{pileup}
\title{Pileup reads from a bam file.}
\usage{
pileup(gr, bampath, binsize = 1, mapqual = 0, shift = 0, ss = F,
  format = T, paired.end = F, paired.end.midpoint = F,
  paired.end.max.frag.length = 1000, verbose = T)
}
\arguments{
\item{gr}{GenomicRanges object used to specify the regions}

\item{bampath}{path to the bam file storing the read. The file must be indexed.
If a range is on the negative strand the profile will be reverse-complemented.}

\item{mapqual}{discard reads with mapping quality strictly lower than this parameter.
The value 0 ensures that no read will be discarded, the value 254 that only reads
with the highest possible mapping quality will be considered.}

\item{shift}{shift the read position by a user-defined number of basepairs. This can
be handy in the analysis of chip-seq data.}

\item{ss}{produce a strand-specific profile or ignore the strand of the read. This option
does not have any effect on the strand of the region. Strand-specific profiles are
twice as long then strand-independent profiles.}

\item{format}{attempts to find a suitable matrix/array format for the count vector.
if the profile is strand-specific one dimension will correspond to sense
and anti-sense strand, if the ranges have all the same width one dimension
will correspond to the range number.}

\item{paired.end}{a logical value indicating whether the bampath contains paired-end
sequencing output. In this case, only first reads in proper mapped pairs are considered
(FLAG 66).}

\item{paired.end.midpoint}{a logical value indicating whether the fragment middle
points of each fragment should be counted. Therefore it uses the tlen information from
the given bam file (MidPoint = fragment_start + int( abs(tlen) / 2) )). For even tlen,
the given midpoint is the round half down real midpoint.}

\item{paired.end.max.frag.length}{an integer indicating which fragments should be
considered in paired-end sequencing data. Default value of 1,000 bases is generally
a good pick.}

\item{If}{the value is set to 1, the method will return basepair-resolution read densities,
for bigger values the density profiles will be binned (and the memory requirements
will scale accordingly).}
}
\value{
a list with the following arguments:
	\item{counts}{the vector containing the read counts. This will be formatted
	into a matrix or an array depending on whether the profile is strand-specific
	and whether the ranges have all the same length.}
	\item{starts, ends}{Vectors defining the boundaries of the count vector.
	To extract counts relative to the i-th range, use
		\code{as.numeric(counts)[starts[i]:ends[i]]},
	or the \code{getSignal} function to preserve the formatting.}
		\item{format}{This element is present if pu$counts is formatted
	differently than a simple vector and it describes the formatting.}
}
\description{
Compute read density in the regions specified by a GenomicRanges object.
A read position is always specified by its 5' end, so a read mapping to the reference strand
is positioned at its leftmost coordinate, a read mapping to the alternative strand
is positioned at its rightmost coordinate. To change that use the \code{shift} parameter
or the \code{coverage} function.
}

